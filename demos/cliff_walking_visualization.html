---
layout: page
title: 悬崖漫步环境可视化
permalink: /demos/cliff-walking/
---

<style>
  /* 隐藏Jekyll自动生成的页面标题 */
  .page-header h1,
  .post-title,
  .page-title,
  h1:first-of-type {
    display: none !important;
  }
  
  /* 可视化容器 - 作用域化样式 */
  .viz-container {
    min-height: 100vh;
    background: linear-gradient(135deg, #f8fafc 0%, #e0f2fe 100%);
    padding: 2rem 1rem;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif;
  }
  
  .viz-container .viz-content {
    max-width: 1400px;
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    gap: 2rem;
  }
  
  /* 标题样式 */
  .viz-container .viz-title {
    text-align: center;
    margin-bottom: 1rem;
  }
  
  .viz-container .viz-title h1 {
    font-size: 3rem;
    font-weight: 800;
    background: linear-gradient(135deg, #2563eb 0%, #7c3aed 50%, #ec4899 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin: 0;
    line-height: 1.2;
  }
  
  .viz-container .viz-subtitle {
    font-size: 1.125rem;
    color: #64748b;
    text-align: center;
    margin: 1rem 0 0 0;
  }
  
  /* 卡片样式 */
  .viz-container .viz-card {
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 0.5rem;
    padding: 1.5rem;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    transition: box-shadow 0.2s ease;
  }
  
  .viz-container .viz-card:hover {
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  }
  
  /* 使用指南 */
  .viz-container .guide-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 1rem;
  }
  
  .viz-container .guide-header .icon {
    font-size: 1.25rem;
  }
  
  .viz-container .guide-header h3 {
    font-size: 1.125rem;
    font-weight: 600;
    color: #1f2937;
    margin: 0;
  }
  
  .viz-container .guide-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1rem;
  }
  
  .viz-container .guide-item {
    display: flex;
    align-items: flex-start;
    gap: 0.5rem;
    font-size: 0.875rem;
    color: #64748b;
  }
  
  .viz-container .guide-item .label {
    font-weight: 500;
    color: #1f2937;
    flex-shrink: 0;
  }
  
  /* 图例样式 */
  .viz-container .legend-title {
    text-align: center;
    font-size: 0.875rem;
    font-weight: 500;
    color: #64748b;
    margin-bottom: 1rem;
  }
  
  .viz-container .legend-items {
    display: flex;
    justify-content: center;
    gap: 1.5rem;
    flex-wrap: wrap;
  }
  
  .viz-container .legend-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0.75rem;
    background: #f1f5f9;
    border-radius: 0.375rem;
    font-size: 0.875rem;
    font-weight: 500;
  }
  
  .viz-container .legend-color {
    width: 1rem;
    height: 1rem;
    border-radius: 0.25rem;
    flex-shrink: 0;
  }
  
  .viz-container .color-start {
    background: linear-gradient(135deg, #22c55e, #15803d);
  }
  
  .viz-container .color-goal {
    background: linear-gradient(135deg, #fbbf24, #f59e0b);
  }
  
  .viz-container .color-cliff {
    background: linear-gradient(135deg, #ef4444, #dc2626);
  }
  
  /* 算法容器 */
  .viz-container .algorithm-card {
    background: white;
    border: 1px solid #e2e8f0;
    border-radius: 0.5rem;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    transition: box-shadow 0.2s ease;
    overflow: hidden;
  }
  
  .viz-container .algorithm-card:hover {
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  }
  
  .viz-container .algorithm-header {
    padding: 1.5rem;
    border-bottom: 1px solid #e2e8f0;
  }
  
  .viz-container .algorithm-header h2 {
    font-size: 1.5rem;
    font-weight: 600;
    text-align: center;
    color: #1f2937;
    margin: 0;
  }
  
  .viz-container .algorithm-content {
    padding: 1.5rem;
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
  }
  
  /* 结果显示 */
  .viz-container .results-display {
    background: #f8fafc;
    border-radius: 0.375rem;
    padding: 1rem;
    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
    font-size: 0.875rem;
    color: #64748b;
  }
  
  .viz-container .result-content {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex-wrap: wrap;
  }
  
  .viz-container .result-icon {
    font-size: 1.125rem;
  }
  
  .viz-container .result-label {
    font-weight: 600;
    color: #1f2937;
  }
  
  .viz-container .result-tag {
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    font-size: 0.75rem;
    font-weight: 500;
  }
  
  .viz-container .tag-blue {
    background: #dbeafe;
    color: #1e40af;
  }
  
  .viz-container .tag-green {
    background: #dcfce7;
    color: #166534;
  }
  
  .viz-container .tag-purple {
    background: #f3e8ff;
    color: #7c2d12;
  }
  
  .viz-container .tag-success {
    color: #059669;
    font-weight: 600;
  }
  
  /* 网格布局 */
  .viz-container .grids-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
    gap: 2rem;
  }
  
  .viz-container .grid-section {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
  }
  
  .viz-container .grid-title {
    font-size: 1.125rem;
    font-weight: 500;
    text-align: center;
    color: #1f2937;
  }
  
  .viz-container .grid-wrapper {
    display: flex;
    justify-content: center;
  }
  
  /* 网格样式 */
  .viz-container .grid-container {
    display: grid;
    grid-template-columns: repeat(12, 40px);
    grid-template-rows: repeat(4, 40px);
    gap: 2px;
    background: white;
    padding: 1rem;
    border-radius: 0.5rem;
    border: 1px solid #e2e8f0;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }
  
  .viz-container .grid-cell {
    width: 40px;
    height: 40px;
    border: 2px solid #e5e7eb;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-weight: 600;
    font-size: 0.75rem;
    border-radius: 0.25rem;
    transition: all 0.2s ease;
    cursor: default;
    background: #ffffff;
  }
  
  .viz-container .grid-cell:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    z-index: 10;
  }
  
  .viz-container .cell-start {
    background: linear-gradient(135deg, #22c55e, #15803d);
    color: white;
    border-color: #15803d;
    box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
  }
  
  .viz-container .cell-goal {
    background: linear-gradient(135deg, #fbbf24, #f59e0b);
    color: white;
    border-color: #f59e0b;
    box-shadow: 0 4px 12px rgba(251, 191, 36, 0.3);
  }
  
  .viz-container .cell-cliff {
    background: linear-gradient(135deg, #ef4444, #dc2626);
    color: white;
    border-color: #dc2626;
    box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
  }
  
  .viz-container .value-text {
    font-size: 0.625rem;
    opacity: 0.9;
    margin-top: 2px;
  }
  
  /* 按钮样式 */
  .viz-container .controls {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 0.75rem;
  }
  
  .viz-container .viz-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    white-space: nowrap;
    border-radius: 0.375rem;
    font-size: 0.875rem;
    font-weight: 500;
    transition: all 0.2s ease;
    cursor: pointer;
    border: none;
    height: 2.5rem;
    padding: 0 1rem;
    min-width: 120px;
    font-family: inherit;
  }
  
  .viz-container .viz-button:focus-visible {
    outline: 2px solid #2563eb;
    outline-offset: 2px;
  }
  
  .viz-container .viz-button:disabled {
    pointer-events: none;
    opacity: 0.5;
  }
  
  .viz-container .btn-primary {
    background: #1f2937;
    color: white;
  }
  
  .viz-container .btn-primary:hover {
    background: #111827;
  }
  
  .viz-container .btn-secondary {
    border: 1px solid #d1d5db;
    background: white;
    color: #1f2937;
  }
  
  .viz-container .btn-secondary:hover {
    background: #f9fafb;
    color: #1f2937;
  }
  
  .viz-container .btn-destructive {
    background: #dc2626;
    color: white;
  }
  
  .viz-container .btn-destructive:hover {
    background: #b91c1c;
  }
  
  /* 动画效果 */
  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
  }
  
  .viz-container .animate-fade-in {
    animation: fadeIn 0.5s ease-out;
  }
  
  @keyframes pulse-update {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.02); }
  }
  
  .viz-container .animate-pulse-update {
    animation: pulse-update 0.6s ease-in-out;
  }
  
  /* 响应式设计 */
  @media (max-width: 768px) {
    .viz-container {
      padding: 1rem 0.5rem;
    }
    
    .viz-container .viz-title h1 {
      font-size: 2.5rem;
    }
    
    .viz-container .grid-container {
      grid-template-columns: repeat(12, 32px);
      grid-template-rows: repeat(4, 32px);
      gap: 1px;
      padding: 0.75rem;
    }
    
    .viz-container .grid-cell {
      width: 32px;
      height: 32px;
      font-size: 0.625rem;
    }
    
    .viz-container .grids-container {
      grid-template-columns: 1fr;
      gap: 1.5rem;
    }
    
    .viz-container .guide-grid {
      grid-template-columns: 1fr;
    }
    
    .viz-container .controls {
      gap: 0.5rem;
    }
    
    .viz-container .viz-button {
      min-width: 100px;
      font-size: 0.8rem;
    }
  }
  
  @media (max-width: 480px) {
    .viz-container .legend-items {
      gap: 1rem;
    }
    
    .viz-container .result-content {
      flex-direction: column;
      align-items: flex-start;
      gap: 0.5rem;
    }
  }
</style>

<div class="viz-container">
  <div class="viz-content">
    
    <!-- 页面标题 -->
    <div class="viz-title">
      <h1>悬崖漫步环境可视化</h1>
      <p class="viz-subtitle">探索强化学习中的策略迭代与价值迭代算法</p>
    </div>
    
    <!-- 使用指南 -->
    <div class="viz-card">
      <div class="guide-header">
        <div class="icon">💡</div>
        <h3>使用指南</h3>
      </div>
      <div class="guide-grid">
        <div class="guide-item">
          <span class="label">完整运行：</span>
          <span>点击「运行策略迭代」或「运行价值迭代」查看完整收敛过程</span>
        </div>
        <div class="guide-item">
          <span class="label">单步调试：</span>
          <span>使用「运行一步迭代」按钮逐步观察算法进展</span>
        </div>
        <div class="guide-item">
          <span class="label">重新开始：</span>
          <span>点击「重置」按钮清空结果并重新初始化</span>
        </div>
        <div class="guide-item">
          <span class="label">对比学习：</span>
          <span>同时运行两种算法，比较它们的收敛速度和最终结果</span>
        </div>
      </div>
    </div>
    
    <!-- 策略迭代 -->
    <div class="algorithm-card">
      <div class="algorithm-header">
        <h2>策略迭代 (Policy Iteration)</h2>
      </div>
      
      <div class="algorithm-content">
        <!-- 结果显示 -->
        <div id="policyIterationResults" class="results-display">
          <div class="result-content">
            <span class="result-icon">🎯</span>
            <span class="result-label">准备就绪</span>
            <span>|</span>
            <span>点击运行按钮开始策略迭代算法</span>
          </div>
        </div>
        
        <!-- 网格显示 -->
        <div class="grids-container">
          <div class="grid-section">
            <h3 class="grid-title">最优策略</h3>
            <div class="grid-wrapper">
              <div class="grid-container" id="policyIterationPolicyGrid"></div>
            </div>
          </div>
          <div class="grid-section">
            <h3 class="grid-title">状态价值</h3>
            <div class="grid-wrapper">
              <div class="grid-container" id="policyIterationValueGrid"></div>
            </div>
          </div>
        </div>
        
        <!-- 控制按钮 -->
        <div class="controls">
          <button id="policyIterationBtn" class="viz-button btn-primary">
            运行策略迭代
          </button>
          <button id="singleStepPolicyBtn" class="viz-button btn-secondary">
            运行一步迭代
          </button>
          <button id="resetPolicyIterationBtn" class="viz-button btn-destructive">
            重置策略迭代
          </button>
        </div>
      </div>
    </div>
    
    <!-- 价值迭代 -->
    <div class="algorithm-card">
      <div class="algorithm-header">
        <h2>价值迭代 (Value Iteration)</h2>
      </div>
      
      <div class="algorithm-content">
        <!-- 结果显示 -->
        <div id="valueIterationResults" class="results-display">
          <div class="result-content">
            <span class="result-icon">🎯</span>
            <span class="result-label">准备就绪</span>
            <span>|</span>
            <span>点击运行按钮开始价值迭代算法</span>
          </div>
        </div>
        
        <!-- 网格显示 -->
        <div class="grids-container">
          <div class="grid-section">
            <h3 class="grid-title">最优策略</h3>
            <div class="grid-wrapper">
              <div class="grid-container" id="valueIterationPolicyGrid"></div>
            </div>
          </div>
          <div class="grid-section">
            <h3 class="grid-title">状态价值</h3>
            <div class="grid-wrapper">
              <div class="grid-container" id="valueIterationValueGrid"></div>
            </div>
          </div>
        </div>
        
        <!-- 控制按钮 -->
        <div class="controls">
          <button id="valueIterationBtn" class="viz-button btn-primary">
            运行价值迭代
          </button>
          <button id="singleStepValueBtn" class="viz-button btn-secondary">
            运行一步迭代
          </button>
          <button id="resetValueIterationBtn" class="viz-button btn-destructive">
            重置价值迭代
          </button>
        </div>
      </div>
    </div>
    
  </div>
</div>

<script>
    /**
     * 悬崖漫步环境
     */
    class CliffWalkingEnv {
      constructor(ncol = 12, nrow = 4) {
        this.ncol = ncol; // 网格世界的列数
        this.nrow = nrow; // 网格世界的行数
        // 转移矩阵 P[state][action] = [{p, next_state, reward, done}]
        this.P = this.createP();
      }

      /**
       * 创建状态转移矩阵
       */
      createP() {
        // 初始化转移矩阵
        const P = Array(this.nrow * this.ncol).fill().map(() => 
          Array(4).fill().map(() => [])
        );

        // 四种动作: 0-上, 1-下, 2-左, 3-右
        const change = [[0, -1], [0, 1], [-1, 0], [1, 0]];
        
        for (let i = 0; i < this.nrow; i++) {
          for (let j = 0; j < this.ncol; j++) {
            for (let a = 0; a < 4; a++) {
              const state = i * this.ncol + j;
              // 判断是否是悬崖或终点
              if (state === this.nrow * this.ncol - 1) {
                // 终点
                P[state][a].push({
                  p: 1.0,
                  next_state: state,
                  reward: 0,
                  done: true
                });
                continue;
              }
              
              if (i === this.nrow - 1 && j > 0 && j < this.ncol - 1) {
                // 悬崖
                P[state][a].push({
                  p: 1.0,
                  next_state: (this.nrow - 1) * this.ncol,
                  reward: -100,
                  done: true
                });
                continue;
              }
              
              // 计算下一个状态
              let next_i = i + change[a][1];
              let next_j = j + change[a][0];
              let reward = -1.0;
              let done = false;
              
              // 边界处理
              if (next_i < 0 || next_i >= this.nrow || 
                  next_j < 0 || next_j >= this.ncol) {
                next_i = i;
                next_j = j;
              }
              
              let next_state = next_i * this.ncol + next_j;
              
              // 如果下一个状态是悬崖
              if (next_i === this.nrow - 1 && next_j > 0 && next_j < this.ncol - 1) {
                next_state = (this.nrow - 1) * this.ncol;
                reward = -100;
                done = true;
              }
              
              // 如果下一个状态是终点
              if (next_state === this.nrow * this.ncol - 1) {
                done = true;
              }
              
              P[state][a].push({
                p: 1.0,
                next_state: next_state,
                reward: reward,
                done: done
              });
            }
          }
        }
        
        return P;
      }
    }

    /**
     * 策略迭代算法
     */
    class PolicyIteration {
      constructor(env, theta = 1e-5, gamma = 0.9) {
        this.env = env;
        this.theta = theta; // 收敛阈值
        this.gamma = gamma; // 折扣因子
        this.v = Array(env.nrow * env.ncol).fill(0); // 状态价值
        this.pi = Array(env.nrow * env.ncol).fill().map(() => 
          Array(4).fill(0.25)
        ); // 初始策略为均匀随机
        this.policyStable = false; // 策略是否稳定
        this.iterationCount = 0; // 迭代次数
        this.evaluationIterations = []; // 每次策略评估的迭代次数
      }

      /**
       * 策略评估
       */
      policyEvaluation() {
        let iteration = 0;
        while (true) {
          let delta = 0;
          for (let s = 0; s < this.env.nrow * this.env.ncol; s++) {
            let v = this.v[s];
            let new_v = 0;
            
            for (let a = 0; a < 4; a++) {
              for (const {p, next_state, reward} of this.env.P[s][a]) {
                new_v += this.pi[s][a] * p * (reward + this.gamma * this.v[next_state]);
              }
            }
            
            this.v[s] = new_v;
            delta = Math.max(delta, Math.abs(v - new_v));
          }
          
          iteration++;
          
          if (delta < this.theta) {
            return iteration;
          }
          
          // 防止无限循环
          if (iteration > 1000) {
            return iteration;
          }
        }
      }

      /**
       * 策略提升
       */
      policyImprovement() {
        let policy_stable = true;
        
        for (let s = 0; s < this.env.nrow * this.env.ncol; s++) {
          const old_action_probs = [...this.pi[s]];
          
          // 计算Q(s,a)
          const q_sa = Array(4).fill(0);
          
          for (let a = 0; a < 4; a++) {
            for (const {p, next_state, reward} of this.env.P[s][a]) {
              q_sa[a] += p * (reward + this.gamma * this.v[next_state]);
            }
          }
          
          // 找到最优动作
          const best_a = q_sa.indexOf(Math.max(...q_sa));
          
          // 更新策略为确定性策略
          this.pi[s] = Array(4).fill(0);
          this.pi[s][best_a] = 1.0;
          
          // 检查策略是否稳定
          if (JSON.stringify(old_action_probs) !== JSON.stringify(this.pi[s])) {
            policy_stable = false;
          }
        }
        
        return policy_stable;
      }

      /**
       * 策略迭代
       */
      policyIteration() {
        this.policyStable = false;
        this.iterationCount = 0;
        this.evaluationIterations = [];
        
        while (!this.policyStable) {
          const evalIterations = this.policyEvaluation();
          this.evaluationIterations.push(evalIterations);
          
          this.policyStable = this.policyImprovement();
          this.iterationCount++;
          
          // 防止无限循环
          if (this.iterationCount > 20) {
            break;
          }
        }
        
        return {
          policyIterations: this.iterationCount,
          policyEvaluation: this.evaluationIterations
        };
      }
      
      /**
       * 执行单步策略迭代
       */
      singleStepIteration() {
        if (this.policyStable) {
          return {
            policyIterations: this.iterationCount,
            policyEvaluation: this.evaluationIterations,
            isComplete: true
          };
        }
        
        const evalIterations = this.policyEvaluation();
        this.evaluationIterations.push(evalIterations);
        
        this.policyStable = this.policyImprovement();
        this.iterationCount++;
        
        // 防止无限循环
        if (this.iterationCount > 20) {
          this.policyStable = true;
        }
        
        return {
          policyIterations: this.iterationCount,
          policyEvaluation: this.evaluationIterations,
          isComplete: this.policyStable
        };
      }
    }

    /**
     * 价值迭代算法
     */
    class ValueIteration {
      constructor(env, theta = 1e-5, gamma = 0.9) {
        this.env = env;
        this.theta = theta; // 收敛阈值
        this.gamma = gamma; // 折扣因子
        this.v = Array(env.nrow * env.ncol).fill(0); // 状态价值
        this.pi = Array(env.nrow * env.ncol).fill().map(() => 
          Array(4).fill(0.25)
        ); // 策略
        this.iterationCount = 0; // 迭代次数
        this.isComplete = false; // 是否完成
        this.maxDelta = Infinity; // 最大误差
      }

      /**
       * 价值迭代
       */
      valueIteration() {
        this.iterationCount = 0;
        this.isComplete = false;
        this.maxDelta = Infinity;
        
        while (!this.isComplete) {
          const result = this.singleStepIteration();
          if (result.isComplete) {
            break;
          }
        }
        
        return this.iterationCount;
      }
      
      /**
       * 执行单步价值迭代
       */
      singleStepIteration() {
        if (this.isComplete) {
          return {
            iterationCount: this.iterationCount,
            isComplete: true
          };
        }
        
        let delta = 0;
        this.iterationCount++;
        
        for (let s = 0; s < this.env.nrow * this.env.ncol; s++) {
          const v = this.v[s];
          
          // 计算每个动作的价值
          const q_sa = Array(4).fill(0);
          
          for (let a = 0; a < 4; a++) {
            for (const {p, next_state, reward} of this.env.P[s][a]) {
              q_sa[a] += p * (reward + this.gamma * this.v[next_state]);
            }
          }
          
          // 更新状态价值为最大的动作价值
          this.v[s] = Math.max(...q_sa);
          
          // 计算最大误差
          delta = Math.max(delta, Math.abs(v - this.v[s]));
        }
        
        this.maxDelta = delta;
        
        // 在每次迭代后更新策略，而不是等到收敛
        this.extractPolicy();
        
        // 检查是否收敛
        if (delta < this.theta || this.iterationCount > 1000) {
          this.isComplete = true;
        }
        
        return {
          iterationCount: this.iterationCount,
          maxDelta: this.maxDelta,
          isComplete: this.isComplete
        };
      }
      
      /**
       * 从价值函数提取策略
       */
      extractPolicy() {
        for (let s = 0; s < this.env.nrow * this.env.ncol; s++) {
          const q_sa = Array(4).fill(0);
          
          for (let a = 0; a < 4; a++) {
            for (const {p, next_state, reward} of this.env.P[s][a]) {
              q_sa[a] += p * (reward + this.gamma * this.v[next_state]);
            }
          }
          
          // 找到最优动作
          const best_a = q_sa.indexOf(Math.max(...q_sa));
          
          // 更新策略为确定性策略
          this.pi[s] = Array(4).fill(0);
          this.pi[s][best_a] = 1.0;
        }
      }
    }

    // 初始化环境
    const env = new CliffWalkingEnv();
    const actionMeaning = ['↑', '↓', '←', '→'];
    
    // 悬崖位置和目标位置
    const cliffPos = Array.from({length: 10}, (_, i) => (env.nrow - 1) * env.ncol + i + 1);
    const goalPos = [env.nrow * env.ncol - 1];
    const startPos = (env.nrow - 1) * env.ncol;
    
    // 生成随机策略
    function generateRandomPolicy() {
      // 创建大小为4的数组，表示四个动作的概率
      const policy = Array(4).fill(0);
      
      // 随机选择一个动作赋予100%概率
      const randomAction = Math.floor(Math.random() * 4);
      policy[randomAction] = 1.0;
      
      return policy;
    }
    
    // 创建初始随机策略
    let randomPolicies = Array(env.nrow * env.ncol).fill().map(() => 
      generateRandomPolicy()
    );
    
    // 创建所有网格
    function createAllGrids() {
      createGrid('policyIterationValueGrid');
      createGrid('policyIterationPolicyGrid');
      createGrid('valueIterationValueGrid');
      createGrid('valueIterationPolicyGrid');
    }
    
    // 创建网格
    function createGrid(gridId) {
      const gridContainer = document.getElementById(gridId);
      gridContainer.innerHTML = '';
      
      for (let i = 0; i < env.nrow; i++) {
        for (let j = 0; j < env.ncol; j++) {
          const cell = document.createElement('div');
          cell.className = 'grid-cell';
          
          const state = i * env.ncol + j;
          
          // 设置单元格类型
          if (state === startPos) {
            cell.classList.add('cell-start');
            cell.innerHTML = 'S';
          } else if (state === goalPos[0]) {
            cell.classList.add('cell-goal');
            cell.innerHTML = 'G';
          } else if (cliffPos.includes(state)) {
            cell.classList.add('cell-cliff');
            cell.innerHTML = 'C';
          }
          
          gridContainer.appendChild(cell);
        }
      }
    }
    
    // 显示初始环境状态
    function showInitialState() {
      // 显示所有状态值为0
      showInitialValues('policyIterationValueGrid');
      showInitialValues('valueIterationValueGrid');
      
      // 显示随机策略
      showInitialPolicies('policyIterationPolicyGrid');
      showInitialPolicies('valueIterationPolicyGrid');
      
      // 显示默认结果提示
      document.getElementById('policyIterationResults').innerHTML = 
        '<div class="result-content"><span class="result-icon">🎯</span><span class="result-label">准备就绪</span><span>|</span><span>点击运行按钮开始策略迭代算法</span></div>';
      document.getElementById('valueIterationResults').innerHTML = 
        '<div class="result-content"><span class="result-icon">🎯</span><span class="result-label">准备就绪</span><span>|</span><span>点击运行按钮开始价值迭代算法</span></div>';
    }
    
    // 显示初始状态值
    function showInitialValues(gridId) {
      const cells = document.querySelectorAll(`#${gridId} .grid-cell`);
      
      for (let i = 0; i < env.nrow; i++) {
        for (let j = 0; j < env.ncol; j++) {
          const state = i * env.ncol + j;
          const cell = cells[state];
          
          // 显示状态价值
          if (state === startPos) {
            cell.classList.add('cell-start');
            cell.innerHTML = `S<br><span class="value-text">0.00</span>`;
          } else if (state === goalPos[0]) {
            cell.classList.add('cell-goal');
            cell.innerHTML = `G<br><span class="value-text">0.00</span>`;
          } else if (cliffPos.includes(state)) {
            cell.classList.add('cell-cliff');
            cell.innerHTML = `C<br><span class="value-text">0.00</span>`;
          } else {
            cell.innerHTML = `<span class="value-text">0.00</span>`;
          }
        }
      }
    }
    
    // 显示初始随机策略
    function showInitialPolicies(gridId) {
      const cells = document.querySelectorAll(`#${gridId} .grid-cell`);
      
      for (let i = 0; i < env.nrow; i++) {
        for (let j = 0; j < env.ncol; j++) {
          const state = i * env.ncol + j;
          const cell = cells[state];
          
          if (state === startPos) {
            cell.innerHTML = 'S';
          } else if (state === goalPos[0]) {
            cell.innerHTML = 'G';
          } else if (cliffPos.includes(state)) {
            cell.innerHTML = 'C';
          } else {
            // 显示随机策略方向
            const best_a = randomPolicies[state].indexOf(1.0);
            cell.innerHTML = actionMeaning[best_a];
          }
        }
      }
    }
    
    // 更新状态价值网格
    function updateValueGrid(agent, gridId) {
      const cells = document.querySelectorAll(`#${gridId} .grid-cell`);
      
      for (let i = 0; i < env.nrow; i++) {
        for (let j = 0; j < env.ncol; j++) {
          const state = i * env.ncol + j;
          const cell = cells[state];
          
          // 显示状态价值
          const stateValue = agent.v[state].toFixed(2);
          
          // 设置单元格类型和内容
          if (state === startPos) {
            cell.classList.add('cell-start');
            cell.innerHTML = `S<br><span class="value-text">${stateValue}</span>`;
          } else if (state === goalPos[0]) {
            cell.classList.add('cell-goal');
            cell.innerHTML = `G<br><span class="value-text">${stateValue}</span>`;
          } else if (cliffPos.includes(state)) {
            cell.classList.add('cell-cliff');
            cell.innerHTML = `C<br><span class="value-text">${stateValue}</span>`;
          } else {
            cell.innerHTML = `<span class="value-text">${stateValue}</span>`;
          }
        }
      }
    }
    
    // 更新策略网格
    function updatePolicyGrid(agent, gridId) {
      const cells = document.querySelectorAll(`#${gridId} .grid-cell`);
      
      for (let i = 0; i < env.nrow; i++) {
        for (let j = 0; j < env.ncol; j++) {
          const state = i * env.ncol + j;
          const cell = cells[state];
          
          // 设置单元格类型和内容
          if (state === startPos) {
            cell.classList.add('cell-start');
            cell.innerHTML = 'S';
          } else if (state === goalPos[0]) {
            cell.classList.add('cell-goal');
            cell.innerHTML = 'G';
          } else if (cliffPos.includes(state)) {
            cell.classList.add('cell-cliff');
            cell.innerHTML = 'C';
          } else {
            // 找到最优动作
            const best_a = agent.pi[state].indexOf(Math.max(...agent.pi[state]));
            cell.innerHTML = actionMeaning[best_a];
          }
        }
      }
    }
    
    // 重置策略迭代环境
    function resetPolicyIteration() {
      // 重新生成随机策略
      randomPolicies = Array(env.nrow * env.ncol).fill().map(() => 
        generateRandomPolicy()
      );
      
      // 重置算法实例
      policyAgent = null;
      
      // 显示初始状态
      showInitialValues('policyIterationValueGrid');
      showInitialPolicies('policyIterationPolicyGrid');
      
      // 显示默认结果提示
      document.getElementById('policyIterationResults').innerHTML = 
        '<div class="result-content"><span class="result-icon">🎯</span><span class="result-label">准备就绪</span><span>|</span><span>点击运行按钮开始策略迭代算法</span></div>';
    }
    
    // 重置价值迭代环境
    function resetValueIteration() {
      // 重新生成随机策略
      randomPolicies = Array(env.nrow * env.ncol).fill().map(() => 
        generateRandomPolicy()
      );
      
      // 重置算法实例
      valueAgent = null;
      
      // 显示初始状态
      showInitialValues('valueIterationValueGrid');
      showInitialPolicies('valueIterationPolicyGrid');
      
      // 显示默认结果提示
      document.getElementById('valueIterationResults').innerHTML = 
        '<div class="result-content"><span class="result-icon">🎯</span><span class="result-label">准备就绪</span><span>|</span><span>点击运行按钮开始价值迭代算法</span></div>';
    }
    
    // 显示结果
    function showResults(algorithmName, agent, iterations) {
      const resultsId = algorithmName === '策略迭代' ? 'policyIterationResults' : 'valueIterationResults';
      const resultsDiv = document.getElementById(resultsId);
      let html = '';
      
      if (algorithmName === '策略迭代') {
        html += `<div class="animate-fade-in">`;
        html += `<div class="result-content">`;
        html += `<span class="result-icon">📊</span>`;
        html += `<span class="result-label">策略迭代次数:</span>`;
        html += `<span class="result-tag tag-blue">${iterations.policyIterations}</span>`;
        html += `<span>|</span>`;
        html += `<span class="result-label">每次策略评估:</span>`;
        html += `<span class="result-tag tag-green">${iterations.policyEvaluation.join(', ')}</span>`;
        if (iterations.isComplete) {
          html += `<span>|</span><span class="tag-success">✅ 策略已收敛!</span>`;
        }
        html += `</div>`;
        html += `</div>`;
      } else {
        html += `<div class="animate-fade-in">`;
        html += `<div class="result-content">`;
        html += `<span class="result-icon">📈</span>`;
        html += `<span class="result-label">价值迭代次数:</span>`;
        html += `<span class="result-tag tag-blue">${iterations.iterationCount}</span>`;
        html += `<span>|</span>`;
        html += `<span class="result-label">最大误差:</span>`;
        html += `<span class="result-tag tag-purple">${iterations.maxDelta?.toFixed(5) || 'N/A'}</span>`;
        if (iterations.isComplete) {
          html += `<span>|</span><span class="tag-success">✅ 价值已收敛!</span>`;
        }
        html += `</div>`;
        html += `</div>`;
      }
      
      resultsDiv.innerHTML = html;
    }
    
    // 添加网格更新动画
    function animateGridUpdate(gridId) {
      const grid = document.getElementById(gridId);
      grid.classList.add('animate-pulse-update');
      setTimeout(() => {
        grid.classList.remove('animate-pulse-update');
      }, 600);
    }
    
    // 全局算法实例
    let policyAgent = null;
    let valueAgent = null;
    
    // 绑定按钮事件
    document.getElementById('policyIterationBtn').addEventListener('click', function() {
      policyAgent = new PolicyIteration(env);
      const iterations = policyAgent.policyIteration();
      updateValueGrid(policyAgent, 'policyIterationValueGrid');
      updatePolicyGrid(policyAgent, 'policyIterationPolicyGrid');
      animateGridUpdate('policyIterationValueGrid');
      animateGridUpdate('policyIterationPolicyGrid');
      showResults('策略迭代', policyAgent, iterations);
    });
    
    document.getElementById('valueIterationBtn').addEventListener('click', function() {
      valueAgent = new ValueIteration(env);
      const iterations = valueAgent.valueIteration();
      updateValueGrid(valueAgent, 'valueIterationValueGrid');
      updatePolicyGrid(valueAgent, 'valueIterationPolicyGrid');
      animateGridUpdate('valueIterationValueGrid');
      animateGridUpdate('valueIterationPolicyGrid');
      showResults('价值迭代', valueAgent, {
        iterationCount: iterations,
        maxDelta: valueAgent.maxDelta,
        isComplete: valueAgent.isComplete
      });
    });
    
    document.getElementById('singleStepPolicyBtn').addEventListener('click', function() {
      // 如果没有实例，创建一个新的
      if (!policyAgent) {
        policyAgent = new PolicyIteration(env);
      }
      
      // 运行一步迭代
      const iterations = policyAgent.singleStepIteration();
      
      // 更新视图
      updateValueGrid(policyAgent, 'policyIterationValueGrid');
      updatePolicyGrid(policyAgent, 'policyIterationPolicyGrid');
      animateGridUpdate('policyIterationValueGrid');
      animateGridUpdate('policyIterationPolicyGrid');
      showResults('策略迭代', policyAgent, iterations);
    });
    
    document.getElementById('singleStepValueBtn').addEventListener('click', function() {
      // 如果没有实例，创建一个新的
      if (!valueAgent) {
        valueAgent = new ValueIteration(env);
      }
      
      // 运行一步迭代
      const iterations = valueAgent.singleStepIteration();
      
      // 更新视图
      updateValueGrid(valueAgent, 'valueIterationValueGrid');
      updatePolicyGrid(valueAgent, 'valueIterationPolicyGrid');
      animateGridUpdate('valueIterationValueGrid');
      animateGridUpdate('valueIterationPolicyGrid');
      showResults('价值迭代', valueAgent, iterations);
    });
    
    document.getElementById('resetPolicyIterationBtn').addEventListener('click', function() {
      resetPolicyIteration();
      animateGridUpdate('policyIterationValueGrid');
      animateGridUpdate('policyIterationPolicyGrid');
    });
    
    document.getElementById('resetValueIterationBtn').addEventListener('click', function() {
      resetValueIteration();
      animateGridUpdate('valueIterationValueGrid');
      animateGridUpdate('valueIterationPolicyGrid');
    });
    
    // 初始化所有网格
    createAllGrids();
    
    // 初始显示环境状态
    showInitialState();
</script> 